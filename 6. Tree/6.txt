19 вариант

Условие задания: Построить дерево в соответствии со своим вариантом задания. Вывести его на 
экран в виде дерева. Реализовать основные операции работы с деревом: обход дерева, включение,  
исключение и поиск узлов. Сравнить эффективность алгоритмов сортировки и поиска в зависимости 
от высоты деревьев и степени их ветвления.

Описание ТЗ: 5.	Построить частотный словарь из слов текстового файла в виде дерева двоичного 
поиска. Вывести его на экран в виде дерева. Осуществить поиск указанного слова в дереве и в 
файле. Если слова нет, то (по желанию пользователя) добавить его в дерево и, соответственно, в 
файл. Сравнить время поиска слова в дереве и в файле.


Структура данных:
struct TreeType *starttree = (struct TreeType*)malloc(sizeof(struct TreeType));  //  Начало дерева
//  Тип элемента дерева
struct TreeType
{
	char value[100];  //  Слово в дереве	
	int frequence;  //  Частота повторений слова в файле
	struct TreeType *left;  //  Левый потомок
	struct TreeType *right;  //  Правый потомок
};




Описание алгоритма:
Обход (вершина дерева):
	если лист, то выход;
	Обход (левый потомок);
	Обход (правый потомок);

Вставка (вершина, элемент)
	если значение<элемент
		если нет правого потомка
			правый потомок = элемент;
			выход;
		иначе
			Вставка(правый потомок, элемент);
	иначе
		если нет левого потомка
			левый потомок = элемент;
			выход;
		иначе
			Вставка (левый потомок, элемент);

Удаление (вершина, элемент)
	если значение=элемент
		переписать вершину;
		выход;
	если есть правый потомок
		удаление (правый потомок, элемент);	
	если есть левый потомок
		удаление (правый потомок, элемент);
		
Поиск (вершина, элемент)
если значение = элемент
	вернуть 1;
если элемент > значение
	Поиск(правый потомок, элемент);
если элемент <= значение
	Поиск(левый потомок, элемент);	



Проверка производительности: При малом количестве элементов эффективнее использовать обычный
массив, так как в этом случае весьма ощутимо время на работу с элементами дерева. При большом 
количестве элементов выгоднее использовать дерево, так как уменьшается число сравнений. В моем
случае получилось, что при 30-и элементах поиск в дереве оказался в 2 раза быстрее поиска в 
файле. Если дерево слабо ветвится, то его обработка тоже будет неэффективной, так как количество
сравнений примерно такое же, как и в массиве.
5 элементов:  Поиск в дереве:  744
	      Поиск в файле:  438
10 элементов: Поиск в дереве:  1034
	      Поиск в файле:  816
15 элементов: Поиск в дереве:  1113
	      Поиск в файле:  957
30 элементов: Поиск в дереве:  585
	      Поиск в файле:  927
Малое ветвление: Поиск в дереве:  2380
		 Поиск в файле:  933

Контрольные вопросы:
1. Дерево – это нелинейная структура данных, используемая для представления иерархических 
связей, имеющих отношение «один ко многим». 
2. Память выделяется динамически под каждый элемент.
3. Если дерево состоит из вершины, то оно пустое. Если каждый элемент имеет 2 потомка, то
дерево называется бинарным.
4. Обход дерева, включение, исключение и поиск узлов.
5. Дерево, каждый элемент которого имеет максимум 2 потомка и левый потомок меньше предка,
правый потомок больше предка, или наоборот.