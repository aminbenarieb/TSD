//
//  main.c
//  Hash-Table
//
//  Created by Amin Benarieb on 30/11/15.
//  Copyright © 2015 Amin Benarieb. All rights reserved.
//
/*
O 
 
 Удалить все слова, начинающиеся на указанную букву в таблице и в сбалансированном дереве, вывести таблицу.
 Сравнить
 • время поиска,
 • объем памяти
 • количество сравнений
 при использовании хеш-таблиц и сбалансированных деревьев.
 
 Произвести реструктуризацию хеш-таблицы, если среднее количество сравнений больше указанного
 Подсчитать среднее количество сравнений для поиска данных в указанных структурах
 

 Если ключей меньше, чем элементов массива, то в качестве хеш-функции можно принять вычисление остатка от деления целочисленного ключа на размерность массива (m), то есть:
 h(ki) = (ki mod m),
 при n<m, где  n – количество ключей.
 
 Данная функция очень проста, хотя и не самая лучшая. Вообще, можно использовать любую размерность (константу m), но она должна быть такой, чтобы минимизировать число коллизий. Для этого лучше использовать простое число.
 Для символьной строки ключом может являться остаток от деления, например, суммы кодов символов строки на m.
 
 
 Первый метод – внешнее (открытое) хеширование (метод цепочек)
 В случае, когда элемент таблицы с индексом, который вернула хеш-функция, уже занят, к нему присоединяется связный список. Таким образом, если для нескольких различных значений ключа возвращается одинаковое значение хеш-функции, то по этому адресу находится указатель на связанный список, который содержит все значения. Поиск в этом списке осуществляется простым перебором, так как при грамотном выборе хеш-функции любой из списков оказывается достаточно коротким.
 
 Другой путь решения проблемы, связанной с коллизиями – внутреннее (закрытое) хеширование (открытая адресация). Оно, состоит в том, чтобы полностью отказаться от ссылок. В этом случае, если ячейка с вычисленным индексом занята, то можно просто просматривать следующие записи таблицы по порядку (с шагом 1), до тех пор, пока не будет найден ключ K или пустая позиция в таблице. При этом, если индекс следующего просматриваемого элемента определяется добавлением какого-то постоянного шага (от 1 до n), то данный способ разрешения коллизий называется линейной адресацией. Для вычисления шага можно также применить формулу:
 h = h + a2,
 где a – это номер попытки поиска ключа. Этот вид адресации называется квадратичной или произвольной адресацией.
 
 При любом методе разрешения коллизий необходимо ограничить длину поиска элемента. Если для поиска элемента необходимо более 3–4 сравнений, то эффективность использования такой хеш-таблицы пропадает и ее следует реструктуризировать (т.е. найти другую хеш-функцию), чтобы минимизировать количество сравнений для поиска элемента
 
 
 */

#include <stdio.h>
#include "core.h"

int main(void)
{
    tnode *tree = NULL;
    tnode *btree = NULL;
    hashmap hashmap;
    hashmap_closed hashmap_closed;
    char raw_input[BUFFER_MAX_SIZE+1];
    int input;
    int errorCode = 0;
    
    hashtab_init(&hashmap, 11);
    hashtab_closed_init(&hashmap_closed, 11);
    
    do
    {
        input = -1;
        system("clear");
        show_menu();
        
        // Обработка сообщения ошибки
        if (errorCode)
            show_error_message(errorCode);

        printf("❱ ");
        scanf("%s", raw_input);
        
        // Ввода
        if (is_number(raw_input))
        {
            input = atoi(raw_input);
            if (input > 9)
            {
                errorCode = 1;
                continue;
            }
            
            errorCode = 0;

            handle_action(input, &tree, &btree, &hashmap, &hashmap_closed);
        }
        // Обработка пустого ввода (не работает :) )
        else if (*raw_input == ' ' || *raw_input == '\n')
            errorCode = 2;
        else
            errorCode = 1;
        
    }
    while (*raw_input != '0');
    
    // Очищение памяти
    apply_pre(tree, free_node, NULL);
    apply_pre(btree, free_node, NULL);
    hashtab_free(&hashmap);
    
    return 0;
}
